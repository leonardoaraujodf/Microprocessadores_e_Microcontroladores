Data: 31/03/2017

Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1. (a) Escreva uma função em C que calcule a raiz quadrada 'x' de uma variável 'S' do tipo float, utilizando o seguinte algoritmo: após 'n+1' iterações, a raiz quadrada de 'S' é dada por

	x(n+1) = (x(n) + S/x(n))/2

O protótipo da função é:

	unsigned int Raiz_Quadrada(unsigned int S);

int Divisao(int dividendo,int divisor)
{
	if(dividendo >= divisor)
	{
		dividendo -= divisor;
		return (1 + Divisao(dividendo,divisor));
	}
	else
		return 0;
}

int Raiz_Quadrada(float s)
{
	float x=0;
	do 
	{
		if(x==0)
		{
			x=Divisao(s,2);
			x = Divisao((x + Divisao(s,x)),2);
		}
		else
		{
			x = Divisao((x + Divisao(s,x)),2);
		}
	}
	while((x - Divisao((x + Divisao(s,x)),2)) > 1);
	
	return x;
}


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável 'S' é fornecida pelo registrador R15, e a raiz quadrada de 'S' (ou seja, a variável 'x') é fornecida pelo registrador R15 também.

;========================================================================
;               Calcula a divisão de inteiro da forma R15/R14, sem sinal.
;========================================================================
divisao_unsigned: 
        MOV #1,R13
        CMP R14,R15 ; R15 = dividendo, R14 = divisor
        JGE divisao_subtract ; if (R15 >= 14) go to Divisao_subtract
        CLR.W R15 ; return 0 caso R15 seja menor que R14
        RET
divisao_subtract: 
        SUB.W R14,R15 ; R15 = R15 - R14
        PUSH.W R13 ; guarde 1 na pilha
        CALL #divisao_unsigned ; 303
        POP.W R14 ; recupere 1 na pilha
        ADD.W R14,R15 ; return 1 + divisao(dividendo,divisor)
        CLR.W R14; R14 = 0
        CLR.W R13; R13 = 0
        RET

;========================================================================
;           Calcula a raiz quadrada de R15, um inteiro.
;========================================================================

raiz_quadrada: 
        MOV.W #0,R14 ; x = R14 = 0;
iteracao: 
        TST R14; R14 = 0 ?
        JNE else_iteracao; se R14 != 0, vá pra else
        PUSH R15 ; guardar R15 = s na pilha
        MOV.W #2,R14 ; Nesse caso, ainda nao tem problema sobrescrever R14 porque ele é zero nesse momento
        CALL #divisao_unsigned ; Faça Divisao(s,2)
        MOV.W R15,R14 ; x =  Divisao(s,2)
        POP R15 ; recupere S para R15, R15 = s
        CALL #realizar_iteracao ; faça uma iteracao x = Divisao((x + Divisao(s,x)),2);
        JMP condicao_while ; vá para a condicao do laço
        
realizar_iteracao: 
        PUSH R15; guarde S na pilha
        PUSH R14; guarde x na pilha
        CALL #divisao_unsigned ; faça Divisao(s,x)
        MOV.W R15,R13 ; R13 <= Divisao(s,x)
        POP R14 ; recupere x da pilha
        ADD.W R14,R13 ; faça R13 <= Divisao(s,x) + x
        MOV.W R13,R15 ; faça R15 <= R13 <= Divisao(s,x) + x. Esta operacao foi realizada para fazer Divisao((x + Divisao(s,x)),2)
        MOV #2,R14 ; R14 <= 2
        CALL #divisao_unsigned
        MOV R15,R14 ; R14 <= x <= Divisao((x + Divisao(s,x)),2)
        POP R15 ; recupere s da pilha
        RET
        
else_iteracao: 
        CALL #realizar_iteracao

condicao_while: 
        PUSH R14 ; guarde x(n) na pilha
        PUSH R14 ; guarde x(n) na pilha
        CALL #realizar_iteracao
        MOV.W R14,R13 ; R13 <= R14 <= Divisao(x + Divisao(s,x)),2)
        POP R14 ; recupere x(n) da pilha
        SUB.W R13,R14 ; faça R14 = x(n) - Divisao(x + Divisao(s,x)),2)
        MOV.W R14,R13 ; faça R13 = R14
        POP R14 ; recupere x(n) da pilha
        CMP #1, R13 ; comparar R13 com 1
        JGE iteracao ; R13 >= 1, vá para iteracao
                
fim_raiz_quadrada:
        MOV.W R14,R15 ; R15 <= R14
        CLR.W R14 
        CLR.W R13
        RET
        

2. (a) Escreva uma função em C que calcule 'x' elevado à 'N'-ésima potência, seguindo o seguinte protótipo: 

	int Potencia(int x, int N);

int MULT_unsigned(unsigned int a, unsigned int b)
{
	if(b==0) return 0;
	else
	return a+MULT_unsigned(a, (b-1));
}

int Potencia(int x, int N)
{
	if(N==0) return 1;
	else return MULT_unsigned(x,Potencia(x, (N-1)));
}

	

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. 'x' e 'n' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida no registrador R15.



3. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula a divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

Divisao_unsigned:

mov #1,R13
cmp R14,R15 ; R15 = dividendo, R14 = divisor
jge Divisao_Subtract ; if (R15 >= 14) go to Divisao_subtract
clr.w R15 ; return 0 caso R15 seja menor que R14
ret

Divisao_Subtract:

sub.w R14,R15 ; R15 = R15 - R14
pow.w R13 ; guarde 1 na pilha
call Divisao_unsigned 
pop.w R14 ; recupere 1 na pilha
add.w R14,R15 ; return 1 + divisao(dividendo,divisor)
clr.w R14; R14 = 0
ret


4. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

5. (a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, e 0, caso contrário. Siga o seguinte protótipo:

	int Primalidade(unsigned int x);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

6. Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!. Se n for ímpar, n!! = 1*3*5*...*n, e se n for par, n!! = 2*4*6*...*n. Por exemplo, 9!! = 1*3*5*7*9 = 945 e 10!! = 2*4*6*8*10 = 3840. Além disso, 0!! = 1!! = 1.
O protótipo da função é:

	unsigned long long DuploFatorial(unsigned long long n);

7. (a) Escreva uma função em C que calcula a função exponencial da seguinte forma:
	
Considere o cálculo até o termo n = 20. O protótipo da função é double ExpTaylor(double x);
(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430, mas considere que os valores de entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

8. Escreva uma sub-rotina na linguagem Assembly do MSP430 que indica se um vetor esta ordenado de forma decrescente. Por exemplo:
[5 4 3 2 1] e [90 23 20 10] estão ordenados de forma decrescente.
[1 2 3 4 5] e [1 2 3 2] não estão.
O primeiro endereço do vetor é fornecido pelo registrador R15, e o tamanho do vetor é fornecido pelo registrador R14. A saída deverá ser fornecida no registrador R15, valendo 1 quando o vetor estiver ordenado de forma decrescente, e valendo 0 em caso contrário.

9. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o produto escalar de dois vetores, 'a' e 'b':
	
O primeiro endereço do vetor 'a' deverá ser passado através do registrador R15, o primeiro endereço do vetor 'b' deverá ser passado através do registrador R14, e o tamanho do vetor deverá ser passado pelo registrador R13. A saída deverá ser fornecida no registrador R15.

10. (a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo:
	[1 2 3 2 1] e [0 10 20 20 10 0] são palíndromos.
	[5 4 3 2 1] e [1 2 3 2] não são.
Se o vetor for palíndromo, retorne o valor 1. Caso contrário, retorne o valor 0. O protótipo da função é:

	int Palindromo(int vetor[ ], int tamanho);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. O endereço do vetor de entrada é dado pelo registrador R15, o tamanho do vetor é dado pelo registrador R14, e o resultado é dado pelo registrador R15.
